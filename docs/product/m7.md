# M7 — Safety + Resilience

## Goal
Add safety mechanisms and resilience features to prevent runaway polling, handle network failures gracefully, and give users control over polling behavior through configurable settings.

## Primary User Stories
- As a user, if the network fails or I lose connection, I want the app to stop polling automatically and notify me clearly, so I don't waste resources or risk getting rate-limited.
- As a user, if the API repeatedly fails or rate-limits me, I want the app to back off automatically instead of hammering the server, so I don't get blocked.
- As a user, I want to control how aggressively the app polls (cadence, concurrency, max duration) so I can balance speed vs. safety based on my needs.
- As a user, if polling hits a hard limit or terminal failure, I want the app to stop cleanly with a clear explanation, not continue forever.

## Definitions
- **Network Throttle (HTTP 000)**: When requests are temporarily blocked at the infrastructure level (connection refused, rate limited by network layer). In practice, this clears in ~1 second if you pause and retry. **Not a terminal error.**
- **Rate Limiting (HTTP 429)**: When the API signals too many requests. Typically clears quickly with a brief pause.
- **Smart Backoff Strategy**: Brief pause (1-2s) on HTTP 000 or 429, then retry. No exponential backoff (too slow for narrow booking windows). Optionally reduce concurrency to ease pressure.
- **Polling Settings**: User-configurable parameters that control polling behavior (cadence, max duration, concurrency cap).
- **Terminal Failures**: Errors that indicate polling should stop permanently (e.g., inventory unavailable, cart full, auth invalid). Rate limits and network throttles are **not terminal**.

## UX Requirements
1. **Network Throttle Handling (HTTP 000)**
   - Detect HTTP 000 (connection refused, network-level rate limit).
   - **Do not stop** - this is temporary and clears in ~1 second.
   - Pause for 1-2 seconds, then resume polling.
   - Show status: "⚠️ Network throttle: Pausing 1s..." (not an error, just a warning).
   - If HTTP 000 persists for 10+ consecutive attempts, reduce concurrency by 1 (min: 1).
   - Only stop if user manually clicks "Stop" - never auto-stop for HTTP 000.

2. **Rate Limit Handling (HTTP 429)**
   - Detect HTTP 429 responses.
   - **Do not stop** - this is temporary.
   - Pause for 1-2 seconds, then resume polling (no exponential backoff).
   - Show status: "⚠️ Rate limited: Pausing 1s..."
   - If HTTP 429 persists for 10+ consecutive attempts, reduce concurrency by 1 (min: 1).
   - Only stop if user manually clicks "Stop" - never auto-stop for HTTP 429.

3. **Persistent Failure Warning**
   - Track consecutive non-200 responses (exclude expected 417 during queue mode, exclude 000/429).
   - After 20 consecutive failures (400, 500, etc.), show warning: "⚠️ 20+ failures: Consider checking cookies/site."
   - **Do not auto-stop** - let user decide.
   - Reset counter on any 200 or expected 417.

4. **Auto-Concurrency Reduction**
   - When HTTP 000 or 429 persists (10+ consecutive), automatically reduce concurrency.
   - Drop from current level to current - 1 (e.g., 3 → 2 → 1).
   - Never go below 1.
   - Show notification: "⚙️ Reduced concurrency to 2 due to persistent throttling."
   - Reset to configured level on next polling session or after 5 consecutive successful requests.

5. **Polling Settings UI**
   - Add "Settings" section in sidebar (collapsible/expandable).
   - **Cadence (ms)**: Delay between requests (default: 100ms, min: 50ms, max: 5000ms).
   - **Max Duration (seconds)**: Auto-stop after X seconds (default: 300s/5min, min: 30s, max: 600s/10min).
   - **Concurrency**: Max simultaneous requests (default: 3, min: 1, max: 10).
   - "Reset to Defaults" button.
   - Settings persist across sessions (localStorage or config file).

6. **Max Duration Enforcement**
   - When polling starts, track elapsed time.
   - At max duration, stop polling with message: "⏱️ Max duration reached (5m 0s). Adjust settings or restart."
   - Show elapsed time in polling status (e.g., "Elapsed: 2m 34s / 5m 0s").

7. **Clean Stop Behavior**
   - Stop conditions: success, terminal error, manual stop, or max duration timeout.
   - **HTTP 000/429 never trigger stop** - only pause and retry.
   - All stop conditions should:
     - Clear all intervals/timers.
     - Reset UI to idle state.
     - Re-enable form inputs.
     - Log final status to console and status panel.

8. **Manual Override**
   - "Stop" button should always work and immediately halt polling.
   - If countdown is armed, stopping should disarm and reset.

## Acceptance Criteria
- **Network throttle (HTTP 000)**:
  - HTTP 000 detected → pause 1-2s, then resume (no stop).
  - Status shows "⚠️ Network throttle: Pausing 1s..."
  - After 10+ consecutive HTTP 000 → reduce concurrency by 1.
  - Never auto-stops for HTTP 000.
  
- **Rate limiting (HTTP 429)**:
  - HTTP 429 detected → pause 1-2s, then resume (no exponential backoff).
  - Status shows "⚠️ Rate limited: Pausing 1s..."
  - After 10+ consecutive HTTP 429 → reduce concurrency by 1.
  - Never auto-stops for HTTP 429.
  
- **Persistent failures (non-000/429)**:
  - After 20 consecutive failures → show warning (no auto-stop).
  - Counter resets on success or expected 417.
  - User controls when to stop.
  
- **Settings UI**:
  - Settings section in sidebar with cadence, max duration, concurrency controls.
  - Changes take effect on next polling session.
  - Settings persist across app restarts.
  - "Reset to Defaults" button works.
  
- **Max duration**:
  - Polling auto-stops at configured max duration.
  - Elapsed time shown in status panel.
  
- **Clean stops**:
  - All stop conditions properly clean up state.
  - No orphaned intervals or workers.
  - UI always resets to idle correctly.

## Edge Cases
- **Throttle during countdown**: If hit with 000/429 before 8:59 AM, pause briefly and resume. Don't carry pause into countdown start.
- **Settings change during polling**: Current session continues with old settings; new settings apply to next session.
- **Concurrency reduction persists**: Once reduced due to throttling, stays reduced for entire session (resets on next session start).
- **Multiple concurrent 000/429s**: All requests pause together, not individually.
- **Quick succession of 000s**: Each pause is independent; if you get 000 again after pause, pause again (not cumulative).

## Non-Goals (M7)
- Adaptive/smart cadence based on API response patterns (planned for M8).
- Multiple retry strategies or advanced backoff algorithms.
- Persistent queue state across app restarts (already documented limitation).
- API health monitoring or predictive throttling.

## Copy Examples
- Network throttle: "⚠️ Network throttle: Pausing 1s..."
- Rate limited: "⚠️ Rate limited: Pausing 1s..."
- Persistent failures warning: "⚠️ 20+ failures: Consider checking cookies/site."
- Concurrency reduced: "⚙️ Reduced concurrency to 2 due to persistent throttling."
- Max duration: "⏱️ Max duration reached (5m 0s). Adjust settings to run longer."
- Terminal errors still stop: "❌ Already reserved: Dates not available. Select different dates."

## Settings Defaults
- **Cadence**: 100ms (10 req/sec baseline)
- **Max Duration**: 300s (5 minutes)
- **Concurrency**: 3 parallel requests
- **Throttle Pause**: 1000-2000ms (random between 1-2s)
- **Throttle Threshold**: 10 consecutive 000/429 before reducing concurrency
- **Failure Warning Threshold**: 20 consecutive failures (non-000/429)

## Analytics/Telemetry (Optional)
- Track stop reasons (success, network, rate-limit, failures, timeout, manual).
- Track average cadence achieved vs. configured.
- Track backoff events and durations.

## Risks and Mitigations
- **User sets too aggressive cadence**: Warn if cadence < 100ms; show tooltip about throttle risk.
- **Missing booking window due to throttling**: Brief pauses (1-2s) minimize downtime; auto-concurrency reduction helps prevent repeated throttles.
- **Stuck in throttle loop**: After 10+ consecutive throttles, reduce concurrency to ease pressure; user can manually adjust or stop if needed.
- **Real network failure vs. throttle**: Both HTTP 000, but we assume throttle (more common in practice); if truly offline, user will notice and can stop manually.



